## Relevant Files

### UI Components
- `app/renderer/components/KitDetails.tsx` - Main UI for kit details, extended to support comprehensive kit planning with plan mode toggle, slot management, and action controls.
- `app/renderer/components/__tests__/KitDetails.test.tsx` - Unit tests for KitDetails including plan mode, slot actions, and UI interactions.
- `app/renderer/components/KitVoicePanel.tsx` - UI for voice slot drag-and-drop, add/replace/delete actions, plan mode feedback, and stereo assignment.
- `app/renderer/components/__tests__/KitVoicePanel.test.tsx` - Unit tests for KitVoicePanel plan mode, slot actions, and drag-and-drop.
- `app/renderer/components/KitVoicePanels.tsx` - Renders all voice panels, coordinates plan mode state, and handles multi-voice operations.
- `app/renderer/components/__tests__/KitVoicePanels.test.tsx` - Unit tests for KitVoicePanels plan mode integration and voice coordination.
- `app/renderer/components/StatusBar.tsx` - Displays progress, notifications, and status for plan actions and operations.
- `app/renderer/components/__tests__/StatusBar.test.tsx` - Unit tests for StatusBar plan-related notifications and progress display.
- `app/renderer/components/MessageDisplay.tsx` - Notification system for info, warning, error, and progress messages in plan operations.
- `app/renderer/components/__tests__/MessageDisplay.test.tsx` - Unit tests for MessageDisplay plan integration.

### Dialog Components
- `app/renderer/components/dialogs/PlanUpdateDialog.tsx` - UI dialog for SD card update confirmation, change summary, and progress display.
- `app/renderer/components/dialogs/__tests__/PlanUpdateDialog.test.tsx` - Unit tests for update dialog UI and user interactions.
- `app/renderer/components/dialogs/StereoAssignmentDialog.tsx` - UI dialog for handling stereo sample assignment conflicts and user choices.
- `app/renderer/components/dialogs/__tests__/StereoAssignmentDialog.test.tsx` - Unit tests for stereo assignment dialog and conflict resolution.
- `app/renderer/components/dialogs/NewKitDialog.tsx` - UI dialog for creating new kits with name validation and conflict resolution.
- `app/renderer/components/dialogs/__tests__/NewKitDialog.test.tsx` - Unit tests for new kit creation dialog.

### React Hooks
- `app/renderer/components/hooks/useKitPlan.ts` - Hook for all business logic related to kit plans, including plan state, slot management, undo/redo, and persistence.
- `app/renderer/components/hooks/__tests__/useKitPlan.test.ts` - Unit tests for useKitPlan hook covering all plan operations and state management.
- `app/renderer/components/hooks/usePlanUpdate.ts` - Hook for SD card update operations, file copying, format conversion, and progress tracking.
- `app/renderer/components/hooks/__tests__/usePlanUpdate.test.ts` - Unit tests for SD card update operations and progress handling.
- `app/renderer/components/hooks/useStereoHandling.ts` - Hook for stereo sample assignment logic, conflict detection, and settings integration.
- `app/renderer/components/hooks/__tests__/useStereoHandling.test.ts` - Unit tests for stereo handling logic and settings integration.
- `app/renderer/components/hooks/useFilePreview.ts` - Hook for sample preview functionality, format handling, and playback management.
- `app/renderer/components/hooks/__tests__/useFilePreview.test.ts` - Unit tests for file preview and playback functionality.

### Utility Functions
- `app/renderer/components/utils/planUtils.ts` - Utility functions for plan validation, sample assignment, format checks, and stereo handling.
- `app/renderer/components/utils/__tests__/planUtils.test.ts` - Unit tests for all plan utility functions.
- `app/renderer/components/utils/formatValidation.ts` - WAV format validation, conversion rules, and format compatibility checking.
- `app/renderer/components/utils/__tests__/formatValidation.test.ts` - Unit tests for format validation and conversion logic.
- `app/renderer/components/utils/settingsManager.ts` - Manages global settings including 'default to mono samples', confirmation preferences, and plan settings.
- `app/renderer/components/utils/__tests__/settingsManager.test.ts` - Unit tests for settings management and persistence.
- `app/renderer/components/utils/actionHistory.ts` - Action history management for undo/redo operations, including action recording and playback.
- `app/renderer/components/utils/__tests__/actionHistory.test.ts` - Unit tests for action history and undo/redo functionality.

### Context and Settings
- `app/renderer/utils/SettingsContext.tsx` - React context for settings management, including plan-related settings and local store status.
- `app/renderer/utils/__tests__/SettingsContext.test.tsx` - Unit tests for settings context and plan-related state management.

### TypeScript Definitions
- `app/renderer/electron.d.ts` - TypeScript definitions for Electron IPC, extended with plan-related method signatures.

### Database Layer (Main Process)
- `electron/main/db/romperDbCore.ts` - Core logic for Romper DB operations, extended with plan-related tables, action history, and plan state management.
- `electron/main/db/__tests__/romperDbCore.test.ts` - Unit tests for database operations including plan-related schema and operations.
- `electron/main/db/planActions.ts` - Database operations specific to plan actions, action history, and undo/redo support.
- `electron/main/db/__tests__/planActions.test.ts` - Unit tests for plan-specific database operations.
- `electron/main/db/migrations.ts` - Database migration system for schema updates and backwards compatibility.
- `electron/main/db/__tests__/migrations.test.ts` - Unit tests for database migrations and schema validation.

### File Operations (Main Process)
- `electron/main/fileOperations.ts` - Secure file operations for SD card updates, sample copying, and format conversion.
- `electron/main/__tests__/fileOperations.test.ts` - Unit tests for file operations and security validation.
- `electron/main/formatConverter.ts` - Audio format conversion utilities for sample processing during SD card updates.
- `electron/main/__tests__/formatConverter.test.ts` - Unit tests for format conversion and audio processing.

### IPC Layer
- `electron/main/dbIpcHandlers.ts` - Main process IPC handlers for plan operations, extended with plan-specific endpoints.
- `electron/main/__tests__/dbIpcHandlers.test.ts` - Unit tests for plan-related IPC handlers.
- `electron/preload/index.ts` - Electron preload script, extended with plan-related IPC method exposure.
- `electron/preload/__tests__/planIpcMethods.test.ts` - Unit tests for plan-related preload IPC method exposure.

### Shared Types and Utilities
- `shared/planTypesShared.ts` - Shared TypeScript types and interfaces for plan operations between main and renderer processes.
- `shared/__tests__/planTypesShared.test.ts` - Unit tests for shared plan types and validation.

### Notes

- **Plan Mode**: Plan mode is enabled by default for new/user kits (plan_enabled = true) and disabled for imported/factory kits (plan_enabled = false). Users can toggle plan mode manually.
- **Database Schema**: No separate plan table - plan state is tracked via the plan_enabled boolean field in the kits table. Action history is stored in a separate plan_actions table.
- **Stereo Handling**: Complex logic involving the 'default to mono' setting, dual-slot assignment (left→voice N, right→voice N+1), and user prompts for conflicts.
- **Format Validation**: Only WAV files accepted. Must be 8/16 bit, 44100 Hz. Conversion happens when updating SD card, not during planning.
- **File Security**: All file operations must validate paths to prevent directory traversal attacks. Use proper file locking during operations.
- **Undo/Redo**: Complete action history with support for ADD_SAMPLE, REPLACE_SAMPLE, DELETE_SAMPLE, and TOGGLE_PLAN_MODE actions. History persisted in database.
- **UI/UX**: All operations must provide clear feedback, confirmation prompts for destructive actions, and progress indicators for long operations.
- **Sample Storage**: Samples remain in their original filesystem locations. Only source paths are stored in database. No copying to local store until SD card sync.
- **Local Store Role**: Local store serves as the original/factory sample set baseline. User samples are NOT copied to local store - they remain in external locations.
- **SD Card Sync**: During sync, samples are copied directly from source locations to SD card with format conversion as needed.
- **Testing Structure**: Unit tests must be placed in `__tests__` subdirectories alongside the code they test. All plan operations, error conditions, and edge cases must be tested.
- **File Organization**: Follow existing project structure with components, hooks, utils, and dialogs properly organized in their respective directories.
- **Accessibility**: All UI must work in light/dark modes with keyboard navigation and screen reader support.
- Use `npx vitest` to run all tests. Use `npx tsc --noEmit` to validate TypeScript before marking tasks complete.

## Tasks

- [ ] 1.0 Plan Mode Core Functionality
  - [ ] 1.1 Implement plan mode enablement logic:
    - [ ] 1.1.1 Plan mode is ON by default for new/user-created kits (plan_enabled = true)
    - [ ] 1.1.2 Plan mode is OFF by default for imported/factory kits (plan_enabled = false)
    - [ ] 1.1.3 Users can manually toggle plan mode on/off for any kit
    - [ ] 1.1.4 Plan mode state persisted in kits.plan_enabled database field
  - [ ] 1.2 Integrate plan mode status and controls into KitDetails UI:
    - [ ] 1.2.1 Display clear visual indicator of plan mode status (on/off)
    - [ ] 1.2.2 Provide toggle control for enabling/disabling plan mode
    - [ ] 1.2.3 Show appropriate UI feedback when plan mode changes
    - [ ] 1.2.4 Disable plan actions when plan mode is off
  - [ ] 1.3 Implement plan state tracking:
    - [ ] 1.3.1 Track whether plan has unsaved changes
    - [ ] 1.3.2 Mark plan as 'modified' when changes are made after last SD card update
    - [ ] 1.3.3 Display modified status in UI
  - [ ] 1.4 Unit tests for plan mode toggle, persistence, state tracking, and UI feedback.

- [ ] 2.0 Local Store and Romper DB Initialization
  - [x] 2.1 Implement setup wizard with the following flow:
    - [ ] 2.1.1 User chooses the target of the local store:
      - [x] 2.1.1.1 Default is the OS-equivalent 'Documents' folder
      - [x] 2.1.1.2 User can choose a custom path (via folder picker dialog, always appending '/romper' if not present)
      - [x] 2.1.1.3 The `romper` directory will be created in this location
    - [x] 2.1.2 User chooses the source of the local store (three options):
      - [x] 2.1.2.1 From the Rample SD card (card with SD icon)
      - [x] 2.1.2.2 From the Squarp.net archive (card with archive icon)
      - [x] 2.1.2.3 A blank folder (card with folder icon)
    - [x] 2.1.3 Local store is initialized from the source:
      - [x] 2.1.3.1 Kit folder initialization:
        - [x] 2.1.3.1.1 If SD card is the source, copy all files from SD card to local store
        - [x] 2.1.3.1.2 If Squarp.net archive is the source, download and extract archive to local store (with progress bar, robust error handling, and test coverage for premature close and progress events)
        - [x] 2.1.3.1.3 If blank folder is chosen, no files are copied
    - [x] 2.1.4 Progress bar is used for: downloading zip, unzipping/moving files, writing to DB
    - [x] 2.1.5 Enforce step order: cannot proceed to next step until current is valid; allow going back to previous steps. The steps are a) choose source b) choose target c) initialize
    - [ ] 2.1.6 Cancel action is always available and stops any in-progress operation
  - [x] 2.2 Create and initialize Romper DB in `.romperdb` folder within local store.
  - [x] 2.3 Persist local store location in settings; allow changing location
  - [x] 2.4 Upon selection and instantiation of local store files, insert new records into the Romper DB.
  - [x] 2.5 Unit tests for initialization, validation, and error handling.
  - [x] 2.6 Update Romper DB schema to remove plan table, add new kit and sample fields, and update docs/ERD
  - [x] 2.7 Implement initial import to create kit and sample records (no plan table), with new fields
  - [x] 2.8 Update documentation and ERD to match new schema (docs/romper-db.md, docs/romper-db.mmd)
  - [x] 2.9 Store exactly one local store path and associated Romper DB location in application settings; load them on startup if present.
  - [x] 2.10 Transition from SD card-based startup to local store-based startup
    - [x] 2.10.1 Update app startup logic to use local store path instead of SD card path
    - [x] 2.10.2 Show setup wizard immediately on startup if local store is not configured or invalid
    - [x] 2.10.3 Display info message that local store must be set up before app can be used
    - [x] 2.10.4 Close app if user cancels the auto-triggered wizard
    - [x] 2.10.5 Remove "Select SD Card" button from KitBrowserHeader
    - [x] 2.10.6 Update StatusBar to show local store path with database icon instead of SD card info
    - [x] 2.10.7 Update all related unit tests for the SD card to local store transition
  - [x] 2.11 Implement composable scanning operations and database storage
    - [x] 2.11.1 Extend database schema for metadata storage
      - [x] 2.11.1.1 Add kit_alias, kit_artist, locked fields to kits table
      - [x] 2.11.1.2 Add voice_alias field to existing voice-related structure
      - [x] 2.11.1.3 Add step_pattern field for step sequencer use
      - [x] 2.11.1.4 Add wav_bitrate, wav_sample_rate, is_stereo fields to samples table
      - [x] 2.11.1.5 Update database schema documentation in docs/romper-db.md
    - [x] 2.11.2 Implement core scanning operations as composable functions
      - [x] 2.11.2.1 Create voice name inference scanner (from existing function)
      - [x] 2.11.2.2 Create WAV file analysis scanner (bitrate, sample rate, stereo detection)
      - [x] 2.11.2.3 Create RTF artist metadata scanner (from existing function) - Extract artist names from RTF filenames (e.g., "A - Artist Name.rtf") and update the artist field on all kits in that bank
      - [x] 2.11.2.4 Create step pattern scanner for sequencer metadata (SKIPPED - step patterns are internal to app/database)
      - [x] 2.11.2.5 Design scanner orchestration system for composable operation chains
    - [x] 2.11.3 Remove JSON file dependency and migrate to database storage
      - [x] 2.11.3.1 Update scanning logic to store results in database instead of JSON
      - [x] 2.11.3.2 Remove JSON file reading/writing code
      - [x] 2.11.3.3 Update all components to read metadata from database
    - [x] 2.11.4 Unit tests for core scanning operations and database storage
  - [x] 2.12 Implement validation logic to check that the local store kit folders and sample files match the Romper DB metadata.
    - [x] 2.12.1 Create function to retrieve all samples from DB for comparison
    - [x] 2.12.2 Create validation function that checks filesystem against DB records
    - [x] 2.12.3 Identify both missing files (in DB but not filesystem) and extra files (in filesystem but not DB)
    - [x] 2.12.4 Add IPC handler and electron API for validation
    - [x] 2.12.5 Create unit tests for the validation logic
  - [x] 2.13 If the Romper DB metadata is out of sync with the local store, present validation results to the user.
    - [x] 2.13.1 Display a list of kits with validation errors, grouped by error type
    - [x] 2.13.2 Offer the option to rescan problematic kits to correct the database
    - [x] 2.13.3 Clearly inform users that rescanning will update the DB with the current filesystem state
    - [x] 2.13.4 Create unit tests for the validation result UI and rescan functionality
    - [ ] 2.13.5 Integrate validation check into a maintenance menu in the UI
    - [x] 2.13.6 Implement rescan functionality to overwrite DB records with current filesystem state for selected kits
  - [x] 2.14 Flip setup flow: user chooses source first, then target, then import. Update UI, logic, and tests. Decouple UI tests from IPC/Electron.
  - [x] 2.15 Integrate scanning operations into wizard initialization
    - [x] 2.15.1 Add automatic scanning as final step in wizard initialization
      - [x] 2.15.1.1 After database records created, run scanning operation chain
      - [x] 2.15.1.2 Chain: voice inference → WAV analysis → RTF artist scan
      - [x] 2.15.1.3 Show scanning progress on existing wizard progress bar
      - [x] 2.15.1.4 Handle partial failures gracefully (continue chain on errors)
    - [x] 2.15.2 Unit tests for wizard scanning integration
  - [x] 2.16 Update manual scanning functionality
    - [x] 2.16.1 Keep existing "Scan Kit" button in KitDetails page using new operations
    - [x] 2.16.2 Keep existing "Scan All Kits" option in KitBrowser using new operations
    - [x] 2.16.3 Use toast progress bar for manual scanning operations
    - [x] 2.16.4 Simplified to always perform a comprehensive scan (removing individual operation selection)
    - [x] 2.16.5 Handle unscanned kits (prompt user, show appropriate UI state)
    - [x] 2.16.6 Unit tests for manual scanning UI and operations

- [ ] 3.0 Sample Assignment and Slot Management
  - [ ] 3.1 Implement drag-and-drop sample assignment:
    - [ ] 3.1.1 Support dragging single samples to specific slots
    - [ ] 3.1.2 Support dragging multiple samples with auto-assignment to available slots
    - [ ] 3.1.3 Provide clear visual feedback during drag operations
    - [ ] 3.1.4 Show appropriate action messages ("Add sample", "Replace sample")
  - [ ] 3.2 Implement slot action logic:
    - [ ] 3.2.1 Add sample action when dragging to empty slot
    - [ ] 3.2.2 Replace sample action when dragging to occupied slot (with confirmation)
    - [ ] 3.2.3 Delete/remove sample action via UI controls
    - [ ] 3.2.4 All actions must be reversible via undo/redo
  - [ ] 3.3 Enforce hardware constraints:
    - [ ] 3.3.1 Limit to exactly 12 slots per voice (reject assignment beyond limit)
    - [ ] 3.3.2 Limit to exactly 4 voices per kit
    - [ ] 3.3.3 Display slot counts and limits in UI
  - [ ] 3.4 Implement slot validation:
    - [ ] 3.4.1 Validate sample file existence before assignment
    - [ ] 3.4.2 Check file format compatibility (WAV only)
    - [ ] 3.4.3 Show warnings for format issues without blocking assignment
  - [ ] 3.5 Persist all slot changes immediately to Romper DB
  - [ ] 3.6 Unit tests for all slot actions, drag-and-drop logic, constraints, and validation

- [ ] 4.0 WAV Format Validation and Conversion
  - [ ] 4.1 Implement format validation rules:
    - [ ] 4.1.1 Accept only WAV files (reject all other formats)
    - [ ] 4.1.2 Validate bit depth: 8 or 16 bit (reject 24/32 bit)
    - [ ] 4.1.3 Validate sample rate: 44100 Hz (warn for other rates)
    - [ ] 4.1.4 Support both mono and stereo channels
  - [ ] 4.2 Implement validation feedback:
    - [ ] 4.2.1 Display clear error messages for rejected files
    - [ ] 4.2.2 Show warning indicators for samples requiring conversion
    - [ ] 4.2.3 List all format issues in plan UI before SD card update
    - [ ] 4.2.4 Allow users to proceed with warnings (conversion during update)
  - [ ] 4.3 Implement format conversion during SD card update:
    - [ ] 4.3.1 Convert sample rate to 44100 Hz if needed
    - [ ] 4.3.2 Convert bit depth to 16 bit if needed
    - [ ] 4.3.3 Handle mono/stereo conversion based on settings
    - [ ] 4.3.4 Preserve original files, create converted copies
  - [ ] 4.4 Error handling and validation:
    - [ ] 4.4.1 Handle conversion failures gracefully
    - [ ] 4.4.2 Validate converted files before finalizing SD card update
    - [ ] 4.4.3 Rollback changes if conversion fails
  - [ ] 4.5 Unit tests for validation rules, warnings, conversion logic, and error handling

- [ ] 5.0 Stereo Sample Handling and Global Settings
  - [ ] 5.1 Implement 'default to mono samples' global setting:
    - [ ] 5.1.1 Create setting with default value ON
    - [ ] 5.1.2 Persist setting in application settings
    - [ ] 5.1.3 Provide UI toggle in settings/preferences
    - [ ] 5.1.4 Apply setting consistently across all stereo operations
  - [ ] 5.2 Implement stereo sample assignment logic:
    - [ ] 5.2.1 When 'default to mono' is ON: treat all stereo samples as mono
    - [ ] 5.2.2 When 'default to mono' is OFF: implement dual-slot stereo logic
      - [ ] 5.2.2.1 Left channel assigned to target voice/slot
      - [ ] 5.2.2.2 Right channel assigned to same slot in next voice (voice+1)
      - [ ] 5.2.2.3 Check for conflicts in target right-channel slot
    - [ ] 5.2.3 Handle voice 4 edge case: force mono conversion with user warning
    - [ ] 5.2.4 Handle slot conflicts: prompt user to choose mono or replace existing
  - [ ] 5.3 Implement user prompts for ambiguous cases:
    - [ ] 5.3.1 Stereo sample on voice 4: warn about mono conversion
    - [ ] 5.3.2 Right channel slot occupied: offer mono or replace options
    - [ ] 5.3.3 Format conversion required: show impact of mono/stereo choice
  - [ ] 5.4 Implement stereo preview and playback:
    - [ ] 5.4.1 Preview stereo samples as they will sound in target format
    - [ ] 5.4.2 Show visual indicators for stereo pairs in UI
    - [ ] 5.4.3 Handle stereo-to-mono preview mixing
  - [ ] 5.5 Unit tests for stereo logic, settings persistence, user prompts, and preview

- [ ] 6.0 SD Card Update and State Management
  - [ ] 6.1 Implement SD card update workflow:
    - [ ] 6.1.1 Create SD card update confirmation dialog with change summary
    - [ ] 6.1.2 Display list of files to be copied/converted
    - [ ] 6.1.3 Show estimated time and disk space requirements
    - [ ] 6.1.4 Require explicit user confirmation before proceeding
  - [ ] 6.2 Implement SD card update file operations:
    - [ ] 6.2.1 Copy all planned samples to SD card with proper naming
    - [ ] 6.2.2 Convert samples to required format during copy (16-bit, 44100Hz)
    - [ ] 6.2.3 Handle stereo-to-mono conversion based on settings
    - [ ] 6.2.4 Update database to reflect successful SD card sync
  - [ ] 6.3 Implement update state management:
    - [ ] 6.3.1 Mark kit as 'synced' after successful SD card update
    - [ ] 6.3.2 Clear 'modified changes' flag
    - [ ] 6.3.3 Update database with final sync status and metadata
    - [ ] 6.3.4 Handle update rollback on failure
  - [ ] 6.4 Implement batch update functionality:
    - [ ] 6.4.1 Support updating multiple plans to SD card simultaneously
    - [ ] 6.4.2 Show combined progress for batch operations
    - [ ] 6.4.3 Handle partial failures in batch updates
    - [ ] 6.4.4 Provide detailed results for each kit in batch
  - [ ] 6.5 Implement update progress and error handling:
    - [ ] 6.5.1 Show detailed progress during file operations
    - [ ] 6.5.2 Handle file system errors (disk full, permissions, etc.)
    - [ ] 6.5.3 Handle format conversion failures
    - [ ] 6.5.4 Provide clear error messages and recovery options
  - [ ] 6.6 Unit tests for SD card update workflow, file operations, state management, and error handling

- [ ] 7.0 Preview and Playback
  - [ ] 7.1 Implement sample preview functionality:
    - [ ] 7.1.1 Preview unsaved samples from their source locations
    - [ ] 7.1.2 Preview synced samples from SD card when available
    - [ ] 7.1.3 Handle different file formats during preview (before conversion)
    - [ ] 7.1.4 Show loading state during preview file access
  - [ ] 7.2 Implement stereo-to-mono preview:
    - [ ] 7.2.1 Mix stereo samples to mono when 'default to mono' setting is ON
    - [ ] 7.2.2 Preview left/right channels separately when setting is OFF
    - [ ] 7.2.3 Show visual indicators for stereo/mono preview mode
  - [ ] 7.3 Implement sequencer integration:
    - [ ] 7.3.1 Support step sequencer playback with planned samples
    - [ ] 7.3.2 Handle sample loading for sequencer from various sources
    - [ ] 7.3.3 Apply format conversion virtually for sequencer preview
    - [ ] 7.3.4 Provide play/stop controls for planned kits
  - [ ] 7.4 Implement preview error handling:
    - [ ] 7.4.1 Handle missing or inaccessible source files
    - [ ] 7.4.2 Handle corrupt or invalid audio files
    - [ ] 7.4.3 Show clear error messages for preview failures
    - [ ] 7.4.4 Gracefully degrade when preview is unavailable
  - [ ] 7.5 Unit tests for preview functionality, stereo mixing, sequencer integration, and error handling

- [ ] 8.0 Undo/Redo and Action History
  - [ ] 8.1 Design action history data structure:
    - [ ] 8.1.1 Define action types (ADD_SAMPLE, REPLACE_SAMPLE, DELETE_SAMPLE, TOGGLE_PLAN_MODE)
    - [ ] 8.1.2 Store action metadata (timestamp, user, affected slots, file paths)
    - [ ] 8.1.3 Maintain action order with sequence numbers
    - [ ] 8.1.4 Design efficient storage in Romper DB
  - [ ] 8.2 Implement undo functionality:
    - [ ] 8.2.1 Reverse ADD_SAMPLE actions (remove sample from slot)
    - [ ] 8.2.2 Reverse REPLACE_SAMPLE actions (restore previous sample)
    - [ ] 8.2.3 Reverse DELETE_SAMPLE actions (restore deleted sample)
    - [ ] 8.2.4 Handle cascading undos for multi-slot operations
  - [ ] 8.3 Implement redo functionality:
    - [ ] 8.3.1 Re-apply previously undone actions
    - [ ] 8.3.2 Maintain redo stack until new actions are performed
    - [ ] 8.3.3 Clear redo stack when new actions break history chain
  - [ ] 8.4 Implement UI controls:
    - [ ] 8.4.1 Add undo/redo buttons with keyboard shortcuts (Ctrl+Z, Ctrl+Y)
    - [ ] 8.4.2 Show action descriptions in tooltips ("Undo: Add sample to slot 3")
    - [ ] 8.4.3 Enable/disable controls based on available actions
    - [ ] 8.4.4 Show visual feedback during undo/redo operations
  - [ ] 8.5 Implement history persistence:
    - [ ] 8.5.1 Store action history in Romper DB per kit
    - [ ] 8.5.2 Preserve history across app restarts
    - [ ] 8.5.3 Implement history pruning (limit to last N actions)
    - [ ] 8.5.4 Clear history on SD card update (fresh start for synced state)
  - [ ] 8.6 Unit tests for action recording, undo/redo logic, UI controls, and persistence

- [ ] 9.0 Notifications, Progress, and Error Handling
  - [ ] 9.1 Integrate with existing notification system:
    - [ ] 9.1.1 Use MessageDisplay component for all plan-related messages
    - [ ] 9.1.2 Show success notifications for completed actions
    - [ ] 9.1.3 Display warning messages for format issues and conflicts
    - [ ] 9.1.4 Show error notifications for failed operations
  - [ ] 9.2 Implement progress indicators:
    - [ ] 9.2.1 Show progress bars for long-running operations (SD card update, batch update)
    - [ ] 9.2.2 Display detailed progress text ("Copying file 3 of 15...")
    - [ ] 9.2.3 Allow cancellation of long-running operations
    - [ ] 9.2.4 Show estimated time remaining for complex operations
  - [ ] 9.3 Implement confirmation prompts:
    - [ ] 9.3.1 Confirm destructive actions (replace sample, delete sample)
    - [ ] 9.3.2 Confirm SD card update with change summary
    - [ ] 9.3.3 Confirm batch operations affecting multiple kits
    - [ ] 9.3.4 Allow users to disable confirmations for non-destructive actions
  - [ ] 9.4 Implement comprehensive error handling:
    - [ ] 9.4.1 Handle file system errors (permissions, disk space, corruption)
    - [ ] 9.4.2 Handle network errors (for remote file access)
    - [ ] 9.4.3 Handle database errors (corruption, locking, constraint violations)
    - [ ] 9.4.4 Provide recovery suggestions for common error scenarios
  - [ ] 9.5 Unit tests for notifications, progress tracking, confirmations, and error handling

- [ ] 10.0 Accessibility and UI Consistency
  - [ ] 10.1 Implement comprehensive accessibility:
    - [ ] 10.1.1 Ensure all plan UI works in light and dark modes
    - [ ] 10.1.2 Provide keyboard navigation for all plan actions
    - [ ] 10.1.3 Add visible focus indicators for all interactive elements
    - [ ] 10.1.4 Implement proper ARIA labels and roles for screen readers
    - [ ] 10.1.5 Ensure sufficient color contrast for all UI elements
  - [ ] 10.2 Implement consistent visual design:
    - [ ] 10.2.1 Use consistent styling for plan mode indicators
    - [ ] 10.2.2 Standardize drag-and-drop visual feedback
    - [ ] 10.2.3 Ensure consistent button and control styling
    - [ ] 10.2.4 Implement loading states for all async operations
  - [ ] 10.3 Implement responsive layout:
    - [ ] 10.3.1 Ensure plan UI works at different window sizes
    - [ ] 10.3.2 Optimize layout for different screen densities
    - [ ] 10.3.3 Handle overflow scenarios gracefully
  - [ ] 10.4 Implement internationalization foundation:
    - [ ] 10.4.1 Use consistent text keys for all user-visible strings
    - [ ] 10.4.2 Ensure proper text truncation and wrapping
    - [ ] 10.4.3 Support RTL layouts where applicable
  - [ ] 10.5 Unit tests for accessibility features, visual consistency, and responsive behavior

- [x] 11.0 Menu System and Scanning Options
  - [x] 11.1 Move "Scan All Kits" option from KitBrowser to application menu
  - [x] 11.2 Implement application menu structure for scanning and maintenance operations
  - [x] 11.3 Unit tests for menu functionality and scanning operations

- [ ] 12.0 Database Schema and Data Model Updates
  - [ ] 12.1 Implement updated kits table schema:
    - [ ] 12.1.1 Add plan_enabled BOOLEAN field (default false for imported, true for new kits)
    - [ ] 12.1.2 Add plan_synced BOOLEAN field to track SD card sync status
    - [ ] 12.1.3 Add plan_modified_date TIMESTAMP for tracking last changes
    - [ ] 12.1.4 Create indexes for plan-related queries
  - [ ] 12.2 Implement action history table:
    - [ ] 12.2.1 Create plan_actions table (id, kit_id, action_type, action_data, timestamp, sequence)
    - [ ] 12.2.2 Define action_type enumeration (ADD_SAMPLE, REPLACE_SAMPLE, DELETE_SAMPLE, etc.)
    - [ ] 12.2.3 Store action_data as JSON for flexible metadata storage
    - [ ] 12.2.4 Implement efficient querying for undo/redo operations
  - [ ] 12.3 Implement database migration system:
    - [ ] 12.3.1 Create versioned migration scripts for schema updates
    - [ ] 12.3.2 Handle backwards compatibility for existing databases
    - [ ] 12.3.3 Validate schema integrity after migrations
  - [ ] 12.4 Unit tests for schema updates, migrations, and data integrity

- [ ] 13.0 Settings and Configuration Management
  - [ ] 13.1 Implement global plan settings:
    - [ ] 13.1.1 Add 'default to mono samples' setting (boolean, default true)
    - [ ] 13.1.2 Add 'confirm destructive actions' setting (boolean, default true)
    - [ ] 13.1.3 Add 'auto-sync on close' setting (boolean, default false)
    - [ ] 13.1.4 Add 'max undo history' setting (number, default 50)
  - [ ] 13.2 Implement settings persistence and validation:
    - [ ] 13.2.1 Store settings in application configuration
    - [ ] 13.2.2 Validate setting values and provide defaults
    - [ ] 13.2.3 Provide settings UI in preferences/settings panel
    - [ ] 13.2.4 Apply settings changes immediately without restart
  - [ ] 13.3 Unit tests for settings management and validation

- [ ] 14.0 Kit Creation and Duplication
  - [ ] 14.1 Implement new kit creation:
    - [ ] 14.1.1 Create UI for new kit creation with name input
    - [ ] 14.1.2 Validate kit names (format: [A-Z][0-9]{1,2})
    - [ ] 14.1.3 Check for name conflicts and suggest alternatives
    - [ ] 14.1.4 Create kit with plan_enabled = true by default
  - [ ] 14.2 Implement kit duplication:
    - [ ] 14.2.1 Create UI for duplicating existing kits
    - [ ] 14.2.2 Copy all samples and metadata to new kit
    - [ ] 14.2.3 Enable plan mode on duplicated kit
    - [ ] 14.2.4 Handle name generation for duplicated kits
  - [ ] 14.3 Unit tests for kit creation, duplication, and validation

- [ ] 15.0 File System Integration and Management
  - [ ] 15.1 Implement secure file access:
    - [ ] 15.1.1 Validate all file paths for security (prevent directory traversal)
    - [ ] 15.1.2 Handle file system permissions and access errors
    - [ ] 15.1.3 Implement file locking during operations
  - [ ] 15.2 Implement file organization:
    - [ ] 15.2.1 Create proper directory structure in local store
    - [ ] 15.2.2 Generate unique filenames to prevent conflicts
    - [ ] 15.2.3 Handle file cleanup on plan deletion or rollback
  - [ ] 15.3 Implement file monitoring:
    - [ ] 15.3.1 Watch for changes to source files during planning
    - [ ] 15.3.2 Notify users if source files become unavailable
    - [ ] 15.3.3 Handle moved or renamed source files gracefully
  - [ ] 15.4 Unit tests for file security, organization, and monitoring

- `src/renderer/components/KitPlanManager.tsx` - (Deprecated: see KitDetails.tsx) [If still present, this file should be removed after migration.]
- `src/renderer/components/KitPlanManager.test.tsx` - (Deprecated: see KitDetails.test.tsx) [If still present, this file should be removed after migration.]
